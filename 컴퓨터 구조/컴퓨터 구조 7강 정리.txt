1. 시스템 버스

    1. 조직

        1. 버스 : 구성 요소들 간에 교환할 각종 정보들을 전송하는 선들로 구성

        2. 선의 수

            1. 한 번에 전송하는 데이터 비트 수 +

            2. 기억장치 주소 비트들의 수 +

            3. 제어 신호들의 수 = 결정됨

        3. 종류

            1. 데이터 버스

                1. 양방향 전송

                2. 버스 쪽 (선의 수) = CPU와 기억장치 사이에 한 번에 전송되는 비트 수

            2. 주소 버스

                1. 단방향 전송 : CPU -> 기억장치 및 I/O 제어기

                2. 주소 버스의 비트 수에 의해 시스템에 접속될 수 있는 전체 기억장치 용량 결정

                3. 직접 주소지정 할 수 있는 기억장소의 단위 : Byte or Word

                4. 기억장치 용량

                    1. 주소 비트 = 16비트

                        1. 최대 기억장소 수 : 2^16 = 2^6 * 2^10 = 64K

                        2. 바이트 단위 주소 지정일 때 최대 기억장치 용량  = 64K byte

                        3. 32-비트 단어 단위 주소지정일 떄 최대 기억장치 용량 = 4 byte * 2^16 = 256K byte
            
            3. 제어 버스

                1. 기억장치 및 I/O 장치와의 데이터 교환을 위한 제어 신호들의

                    1. 기억장치 쓰기 신호

                    2. 기억장치 읽기 신호

                    3. I/O 쓰기 신호

                    4. I/O 읽기

                2. 버스 중재를 위한 제어 신호들 ( = 중재 버스 )

                    1. 버스 마스터 : 버스 사용의 주체가 되는 요소들

                    2. 버스 중재 : 순서대로 한 개의 마스터 버스를 사용할 수 있게 해주는 동작

                        1. 버스 경합 : 한 개의 시스템 버스 -> 여러 개 버스 마스터들이 동시에 사용 요구하는 현상

                        2. 버스 중재 : 어떤 기준에 따라 마스터들 중 한 개 씩만 선택 -> 순서대로 버스 사용하게 해줄 수 있는 동작

                            1. 중앙집중식 직렬 중재 방식

                                1. 방식

                                    1. 하나의 버스 사용승인 신호선 (BGNT) 데이지-체인 형태로 모든 버스 마스터들을 직렬로 연결

                                    2. 우선 순위 : 버스 승인 신호선이 연결된 순서대로 결정
                                
                                2. 동작 원리

                                    1. 한개 또는 그 이상의 버스 마스터가 버스 사용을 요구 -> 공통의 BREQ 신호 세트

                                    2. 버스 중재기 : 데이지 체인의 첫 번째 접속된 마스터 -> 승인 신호 (BGNT) 전송

                                    3. BGNT 신호 받은 마스터
                                    
                                        1. 만약 버스 사용을 요구한 상태일 시 버스 사용권 가짐

                                        2. 아닐 때는 승인 신호를 다음에 연결된 마스터로 통과

                                        3. 승인 신호 -> 버스를 요구한 마스터에게 도달할 때까지 계속 통과

                                            1. 버스 요구를 보낸 마스터 중 중재기에 가장 가까이 위치한 마스터에게 승인 신호 전달

                                            2. 그 마스터가 버스 사용권 획득
                            
                            2. 분산식 직렬 중재 방식

                                1. 구성

                                    1. 데이지 - 체인 버스 승인 신호선으로  버스 중재기들을 순환형으로 접속

                                2. 동작 원리

                                    1. 버스 사용권을 부여 받은 마스터 -> 버스 사용을 시작하는 순간

                                        1. 해당 마스터의 중재기 -> 자신의 우측에 위치한 마스터의 중재기로 접속된  DBGNT 신호 세트

                                        2. 만약 해당 마스터가 버스 사용을 신청하고 기다릴 시 -> 중재기 : 즉시 DBGNT 신호 받음 -> BGNT 신호 발생 -> 마스터 전송

                                        3. DBGNT 신호 받은 마스터 -> 버스 요구 안할 시 : 해당 신호를 우측의 다음 중재기로 통과

                                            1. 이 과정은 버스를 요구한 마스터에 도달할 때까지 반복
                                
                                3. 특징 : 각 마스터의 우선순위 계속 변화

                                    1. 버스 사용 승인을 받을 시 -> 다음 중재 동작에서느 최하위 우선 순위를 가짐
                                    
                                    2. 버스 사용한 마스터 -> 바로 우측에 위치한 마스터가 최상위 우선 순위를 가짐

                                    3. 순환형 구조 -> DBGNT 신호가 연결된 순서대로 우선 순위 결정
                                
                                4. 단점 : 어느 한 지점에만 결함이 발생해도 전체 시스템의 동작 중단

                        3. 버스 중재기 : 버스를 중재하는 하드웨어 모듈

                        4. 분류 - 제어 신호들의 연결 구조 방식

                            1. 병렬 중재 방식

                                1. 각 버스 마스터들이 독립적인 버스 요구 신호 발생

                                2. 별도의 버스 승인 신호 받음

                                    1. 버스 마스터들의 수와 같은 개수의 버스 요구 선 및 승인 신호 선 필요
                            
                            2. 직렬 중재 방식

                                1. 버스 요구와 승인 신호 선이 각각 한 개씩만 존재

                                2. 각 신호선을 버스 마스터들 간에 직렬로 접속하는 방식
                        
                        5. 분류 - 중재기의 위치에 따른 분류

                            1. 중앙집중식 중재 방식

                                1. 시스템 내 버스 중재기가 한 개만 존재하는 방식

                                2. 버스 마스터 -> 발생하는 버스 요구 신호

                                    1. 하나의 중재기로 보냄

                                    2. 중재기 -> 중재 원칙에 따라 선택한 버스 마스터에게 승인 신호 발생
                            
                            2. 분산식 중재 방식

                                1. 여러 개의 버스 중재기 존재

                                    1. 일반적으로 각 버스 마스터가 중재기를 한 개씩 가짐

                                    2. 버스 중재 동작이 각 마스터의 중재기에 의하여 이루어지는 방식
                        
                        6. 분류 - 우선 순위 결정 방식에 따른 분류

                            1, 고정 - 우선 순위 방식

                                1. 중앙 집중식 고정 - 우선 순위 중재 방식

                                    1. 모든 버스 마스터들이 하나의 버스 중재기에 접속

                                    2. 가장 가까이 위치한 버스 마스터 1이 가장 높은 우선 순위임

                                    3. 버스 마스터 4가 가장 낮은 우선순위를 가지는 것을 가정함

                                    4. 예 : 버스마스터 1이 버스를 사용중일 때, 버스 마스터 3이 버스 사용을 요구하는 경우

                                        1. 마스터 3 -> BREQ3 신호 세트

                                        2. 버스 중재기 -> '마스터 3' BGNT3 신호 세트 -> 버스 사용 허가

                                        3. '마스터 1'이 버스 사용 끝 --> BBUSY 신호 해제

                                        4. '마스터 3' -> BBUSY 신호 다시 세트 -> 버스 사용 시작

                                            1. 이때 BREQ3와 BGNT3 제거
                                    
                                2. 분산식 고정 - 우선 순위 방식

                                    1. 모든 버스 마스터들이 중재기를 한 개씩 보유

                                    2. 중재 동작

                                        1. 각 중재기 -> 자신보다 더 높은 우선 순위를 가진 마스터 : 버스 요구 신호를 받아 검사함

                                        2. 그들이 버스 사용 요구를 하지 않은 경우에만 -> 자신의 버스 마스터로 버스 승인 신호 발생
                                    
                                    장점 : 중재 회로가 간단함 -> 동작 속도 빠름

                                    단점
                                        
                                        1. 고장을 일으키는 중재기 찾는 방법 복잡함

                                        2. 한 중재기의 고장 -> 전체 시스템의 동작에 영향을 미칠 수 있음

                            2. 가변 - 우선 순위 방식

                                1. 시스템의 상태에 따라 각 버스 마스터들의 우선순위를 계속 변화시키는 방식

                                장점 : 모든 마스터 -> 공정하게 버스 사용 가능

                                단점 : 중재 회로 복잡

                                2. 회전 우선순위 방식

                                    1. 방법 1

                                        1. 중재 동작 종료 -> 모든 마스터들의 우선 순위 : 1단계 낮춤

                                        2. 가장 우선순위가 낮았던 마스터 가 최상위 우선순위를 가지도록 함
                                    
                                    2. 방법 2

                                        1. 일단 버스 사용 승인을 받은 마스터 -> 최하위 우선순위 가짐

                                        2. 바로 다음에 위치한 마스터가 최상위 우선순위를 가지도록 함

                                            1. Acceptance-dependent식 회전 우선순위 방식
                                
                                3. 종류

                                    1. 동등 우선순위 방식 : FIFO 알고리즘

                                    2. 임의 우선순위 방식 : 중재 동작이 끝날 때마다 우선순위를 각각 임의로 결정

                                    3. 최소 - 최근 사용 방식 : 가장 오랫동안 사용하지 않은 버스 마스터에게 최상위 우선 순위 할당

                                        단점 : 회로가 매우 복잡함

                5. 버스 대역폭

                    1. 버스 클록의 주기에 의해 경정

                        1. 버스 클록 주기 : 50ns (클록 주파수 = 20MHz), 데이터 버스 폭 : 64비트 (8바이트) 가정

                        2. 버스 대역폭 : 8byte / (50 * 10^(-9)sec) = 160[M bytes / sec]

                            1. 이 버스를 통해 초당 1억 6천 바이트의 데이터 전송 가능

2. 기본 동작

    1. 쓰기 동작

        1. 버스 마스터 -> 버스 사용권 획득

        2. 버스 -> 주소와 데이터 및 쓰기 신호 전송

    2. 읽기 동작

        1. 버스 마스터가 버스 사용권 획득

        2. 주소와 읽기 신호를 보내고 데이터가 전송되어 올 때 까지 대기

    3. 버스 동작의 타이밍에 따른 버스의 분류

        1. 동기식 버스 : 시스템 버스에서 모든 버스 동작들이 공통의 버스 클록을 기준으로 발생

            장점 : 인터페이스 회로 간단, 일반적인 컴퓨터 시스템

            단점

                1. 버스 클럭의 주기가 가장 오래 걸리는 버스 동작의 소요 시간을 기준으로 결정됨

                2. 클록 주기가 더 짧은 시간이 걸릴 때 -> 동작이 완료된 이후에도 다음 주기가 시작될 때까지 대기

        2. 비동기식 버스 : 버스 동작들의 발생 시간이 관련된 다른 버스 동작의 발생 여부에 따라 결정

            장점 : 동기식 버스에서와 같이 낭비되는 시간이 없음, 소규모 컴퓨터

            단점 : 연속적 동작을 처리하기 위한 인터페이스 회로 복잡

3. 폴링 방식

    1. 버스 사용을 원하는 마스터가 있는 지 여부 -> 버스 중재기가 주기적으로 검사 -> 사용 승인 여부 결정

    2. 종류

        1. 하드웨어 폴링 방식

            1. 버스 중재기와 각 버스 마스터 간에 별도의 폴링 선이 존재

            2. 2진 코드화된 폴링 주소 이용 -> 폴링 선의 수 : log_2 N 개 감소

            3. 공통의 BREQ 선과  BBUSY 선이 각각 한 개씩 존재
        
            4. 동작 순서

                1. 중재기 -> 폴링 주소 발생 -> 검사할 마스터 지정

                2. 해당 마스터가 버스 사용을 원하는지 물어봄

                3. 지정된 마스터 -> 버스 사용 원할 시 : BREQ 신호 세트

                4. BREQ 신호 세트 -> 중재기
                
                    1. if : 현재 검사 중인 마스터에게 버스 사용 허가

                    2. else : 다음 마스터들에 대한 검사를 순서대로 진행
            
            5. 우선 순위 결정 방법

                1. 중재기 -> 마스터를 검사하는 순서에 의해 결정

                2. 검사할 마스터의 번호 : 2진 카운터를 이용하여 발생
        
        2. 소프트웨어 폴링 방식

            1. 동작 원리 : 폴링의 순서와 과정을 버스 중재기 내의 프로세서가 관장하는 방식

            장점 : 우선 순위의 변경이 용이

            단점 : 프로그램 실행 -> 하드웨어 방식에 비하여 속도가 더 큼

4. I/O 장치의 접속

    1. I/O 장치가 시스템 버스에 직접 접속하지 못하는 이유

        1. I/O 장치들은 종류에 따라 제어 방법이 서로 다름

            1. 이런 제어 회로들을 CPU 내부에 모두 포함시키는 것이 불가능함

            2. CPU가 그들을 직접 제어할 수 없음

        2. I/O 장치들의 데이터 전송 속도 < CPU의 데이터 처리 속도

            1. 속도가 서로 다름

            2. 고속의 시스템 버스와 I/O 장치들 사이에 직접 데이터를 교환하는 것은 불가능

        3. I/O 장치들과 CPU가 사용하는 데이터 형식의 길이가 서로 다른 경우가 많음

        4. 결론 : 인터페이스 장치인 I/O 제어기를 사용함

    2. 주요 기능

        1. I/O 장치의 제어, 타이밍 조정

        2. CPU와의 통신 담당

        3. I/O 장치와의 통신 담당

        4. 데이터 버퍼링 기능 수행

        5. 오류 검출

    3. 상태 / 제어 레지스터

        1. 내부적으로 두 개의 레지스터로 구성되지만 주소는 하나만 지정됨

            1. 상태 레지스터 
                
                1. I/O 장치의 상태, 오류 검사 결과 등을 나타내는 비트들로 구성
                
                2. CPU에 의한 읽기 동작 시 선택됨

            2. 제어 레지스터

                1. CPU가 보낸 I/O 명령 단어를 저장

                2. CPU에 의한 쓰기 동삭 시 선택됨
    
    4. 프로그램을 이용한 I/O 

        1. CPU가 반복적으로 I/O 장치의 상태를 검사하면서 I/O 동작을 처리하는 방식

        장점 : 간단함, 별도의 하드웨어 필요하지 않음

        단점 : CPU -> I/O 동작에 직접 관여 -> 그 동안 다른 일을 하지 못함

    5. I/O 주소 지정

        1. 각 I/O 장치 당 두 개씩 주소 할당

            1. 데이터 레지스터 주소는
            
            2. 상태 /제어 레지스터 주소 

        2. I/O 주소 지정 방법

            1. 기억장치 - 사상 I/O

                1. 기억장치 주소 영역 일부분 -> I/O 제어기 내의 레지스터들의 주소로 할당하는 방식

                2. 프로그래밍 -> 기억장치 관련 명령어들을 I/O 장치 제어에도 사용 가능

                    1. LOAD 명령어, STORE 명령어 ...
                
                3. 기억장치 읽기 / 쓰기 신호를 I/O 읽기 / 쓰기 신호로 사용

                    1. 별도의 I/O 제어 신호가 필요하지 않음
            
            2. 예시

                1. 주소 비트들이 10 비트인 경우

                    1. 전체 기억 장소 : 1024

                2. 0~511 -> 기억장치 해당

                3. 512~ 1023 -> I/O 장치 해당

                4. 프린터 출력 과정

                    1. 데이터 레지스터 주소 : 512번지

                    2. 상태 - 제어 레지서트 주소 : 513번지

                    3. 상태 레지스터 최하위 비트 : RDY 비트로 사용

                    4. 제어 레지스터 최상위 비트 : 프린트 시작 비트로 사용
            
            장점 : 프로그래밍이 용이함

            단점 : 기억장치 주소 공간이 감소

            2. 분리형 I/O

                1. I/O 장치 주소 공간을 기억장치 주소 공간과는 별도로 할당하는 방식

                2. I/O 제어를 위해서 별도의 I/O 명령어 사용

                    1. IN, OUT 명렁어

                3. 별도의 I/O 읽기 / 쓰기 신호 필요

                4. 예시

                    1. 주소 비트 수 10개 -> 1024개 할당 가능

                        1. 0~1023 : I/O 주소 공간 & 기억장치 주소 공간
                
                장점 : I/O 주소공간으로 인하여 기억장치 주소 공간이 줄어들지 않음

                단점 : I/O 제어를 위해 I/O 명령어들만 이용할 수 있음 -> 프로그래밍 불편함

                5. 프린터 출력 프로그램

                    1. I/O 장치의 데이터 레지스터 주소 : 0번지

                    2. 상태 / 제어 레지스터 주소 : 1번지

5. 인터럽트를 이용한 I/O

    1. 인터럽트 매커니즘 이용

    2. I/O 동작 진행 중 -> CPU : 다른 작업을 처리할 수 있도록 함

    3. 동작 순서

        1. CPU -> I/O 제어기에 명령 전송, CPU : 다른 작업 수행

        2. 제어기 : I/O 장치를 제어 -> I/O 명령 수행

        3. I/O 명령 수행 완료 -> 제어기 : CPU로 인터럽트 신호 전송

        4. CPU -> 인터럽트 신호 받음 -> 원래 프로그램 복귀 -> 수행
    
    4. 구현 방법

        1. 다중 - 인터럽트 방식

            1. 각 I/O 제어기와 CPU 사이에 별도의 인터럽트 요구

                1. interrupt request : INTR + Interrupt acknowledge : INTA -> 선을 접속하는 방법
            
            2. 동작 순서

                1. I/O 제어기 #2 -> INTR2 신호 세트

                2. CPU -> INTA2 신호 세트 -> 해당 제어기에 인터럽스 요구 인식 알림

                3. 해당 인터럽트를 위한 서비스 시작

                4. I/O 제어기 2 -> INTR2 신호 해제 (0으로 리셋)

                5. CPU -> INTA2 신호 해제
            
            장점 : CPU -> 인터럽트를 요구한 장치를 쉽게 찾아냄

            단점

                1. 하드웨어 복잡

                접속 가능한 I/O 장치들의 수 -> CPU의 인터럽트 요구 입력 핀의 수에 의해 제한
        
        2. 데이지 - 체인 방식

            1. CPU -> INTA 출력 선 -> I/O 제어기들에 직렬로 연결하는 방식

            2. I/O 장치 -> AIn 입력을 받는 즉시 인터럽트 백터를 데이터 버스를 통해 CPU로 전송

                1. 인터럽트 백터 : 인터럽트의 고유 ID

                2. 인터럽트 백터는 해당 I/O 장치를 위한 인터럽트 서비스 루틴의 시작 주소를 결정하는데 사용

            3. if : AIn 입력을 받은 I/O 장치 -> 인터럽트 요구하지 않은 상태 -> than : 해당 입력을 다음 장치로 통과시킴

            장점
                
                1. INTR, INTA 신호 선이 각각 1개 씩 있음

                2. 하드웨어 간단
            
            단점

                1. 우선순위 낮은 장치들이 서비스를 못 받음

                2. 매우 오랫동안 기다려야 하는 경우 발생

        3. 소프트웨어 폴링 방식

            1. CPU -> 모든 I/O 제어기들에 접속된 TEST I/O 선을 이용 -> 인터럽트를 요구한 장치 검사 방식

                1. TEST I/O 신호 이용

                2. 각 I/O 장치의 인터럽트 플래그가 세트 되어 있는지 검사

                    1. 검사 순서 -> 우선 순위 결정
            
            장점 : 우선순위의 변경이 용이

            단점 : 처리 시간이 오래 걸림

6. 직접기억장치액세스 - DMA

    1. Direct Memory Access (DMA)

        1. CPU의 개입 없이 I/O 장치 - 기억장치 사이에 데이터를 전송하는 방식

            1. 사이클 스틸링이라고 함
        
        2. 방법

            1. CPU -> 주기억장치를 액세스하지 않은 시간 -> 시스템 버스 -> 주기억장치 - I/O 장치 간 데이터 전송

                1. 주기억장치 - 보조저장장치 사이의 블록 - 단위 데이터 전송에 주로 사용
        
        3. 처리 순서

            1. CPU -> DMA 제어기로 아래 정보를 포함한 명령을 전송

                1. I/O 장치의 주소

                2. 연산지정자

                3. 데이터가 쓰여지거나 읽혀질 주기억장치 영역의 시작 주소

                4. 전송될 데이터 단어들의 수
            
            2. DMA 제어기 -> CPU로 버스 요구 신호 전송

            3. CPU -> DMA 제어기로 버스 승인 신호 전송

            4. DMA 제어기가 주기억장치로부터 데이터 읽음 -> 디스크 제어기 전송

                1. 각 데이터에 대해 2,3,4번을 두 번 반복

                    1. 주기억장치 -> DMA 제어기 & DMA 제어기 -> 디스크 제어기 -> 데이터 저장

                    2. 시스템 버스 두 번 사용

            5. 저장할 데이터 남아 있을 시 -> 그 수만큼 2 ~ 4번 동작 반복

            6. 모든 데이터 저장 완료 -> CPU로 INTR 신호 전송 

            7. 문제점

                1. 각 데이터 전송 때마다 시스템 버스를 두 번씩 사용

                    1. 버스 사용량 증가 -> 시스템 성능 저하

            8. 해결책

                1. I/O 장치들을 DMA 제어기에 접속 -> DMA 제어기가 주기억장치를 액세스 할 때만 시스템 버스 사용
            
            9. I/O 버스 사용 -> 한 개의 DMA 제어기 : 다수의 I/O 장치들 지원

                1. 문제점

                    1. I/O 장치 -> 종류, 속도 다양 + 제어 방법 복잡 -> 간단한 구조를 가진 DMA 제어기로 지원하는데 한계가 있음

                    2. 디스크 쓰기 혹은 읽기 동작 -> 데이터 블록의 크기가 512바이트 이상 -> 데이터들을 버퍼링하기 위한 내부 기억장치 필요

                2. 해결책

                    1. I/O 프로세서 사용 -> I/O 채널이라고 부름

7. IOP

    1. 요소

        1. I/O 제어 프로그램 수행 프로세서

        2. 데이터 블록 -> 임시 저장할 수 있는 용량의 지역 기억장치

        3. 시스템 버스 인터페이스 및 버스 마스터 회로

        4. I/O 버스 중재 회로

                