1. 기억 장치의 분류와 특정
	
	1. 기억 장치 엑세스 유형
		1. 순차적 엑세스 : 저장된 정보 -> 처음부터 순서대로 엑세스
			디스크, CD-ROM

		2. 직접 엑세스 : 엑세스할 위치 근처로 직접 이동 -> 순차적 검색 : 최종 위치에 도달
			디스크, CD-ROM

		3, 임의 엑세스 : 주소 -> 직접 기억 장소를 찾아감 -> 어떤 기억장소든 엑세스 시간 동일
			반도체 기억장치

		4. 연관 액세스 : 저장된 내용 -> 특정 비트 비교 -> 일치하는 내용 액세스
			연관 기억장치  

2. 기억 장치의 설계 / 전송 단위 / 주소 지정 단위

	1 주요 특정 : 용량 , 엑세스 속도

	2. 전송 단위 
		1. 주기억 장치 : 단어 단위
		2. 보조저장장치 : 블록 (512 바이트, or 1k 바이트) 단위

	3. 주소지정 단위 : 바이트 or 단어 단위 
		1. 주소 비트 수 A와 주소지정 단위의 수 N관계 : 2^n = N , n = log_2 N

3. 엑세스 속도와 관련된 파라미터들

	1. 엑세스 시간 : 주소와 쓰기 / 읽기 신호가 도착 순간~ 데이터 엑세스가 완료되는 순간까지의 시간
	
	2. 데이터 전송률 : (한 번에 읽혀지는 데이터 비트 수) / (엑세스 시간) 

5. 계층적 기억장치 시스템

    1. 계층화의 필요성 및 효과

        특성

            엑세스 속도 증가 -> 비트당 가격 높아짐
            
            용량 증가 -> 비트당 가격 낮아짐 -> 엑세스 시간 증가

        계층적 기억장치시스템의 기본 구성 개념

            1계층 기억 장치 : 속도 빠름 -> 높은 가격의 기억장치 사용
            
            2계층 기억 장치 : 속도 느림 -> 낮은 가격의 기억장치 사용

                원리 : CPU -> M_L1 -> M_L2

                    1번째 계층 기억 장치 엑세스 시간 : 10ns , A
                    2번째 계층 기억 장치의 엑세스 시간 : 100ms , B
                    엑세스할 정보가 1번쨰 계층 기억 장치에 있을 확률 : 50%, N

                    평균 기억장치 엑세스 시간 : (0.5 * 10ns) + (0.5 * 100ns) = 55ns
                    일반화 : A * N + B * N
    
    3. 기억장치 계층 : 
        
        상위층으로 갈 수록 다음과 같은 특징이 있음

            1. 비트당 가격이 높아짐
            
            2. 용량 감소
            
            3. 엑세스 시간이 짧아짐

            4. CPU에 의한 액세스 빈도 상승
        
        하위층으로 갈 수록 다음과 같은 특징이 있음

            1. 용량이 더 커짐
            
            2. 비트당 가격이 떨어짐

            3. 지역성의 원리 -> 엑세스 빈도는 더 낮아짐
    
        케시 메모리 : 성능 저하 방지를 위해 CPU - 주 기억장치 사이에 있는 고속의 반도체 기억장치

        내부 기억장치 : CPU 레지스터, 캐시 메모리, 주 기억 장치

        외부 기억장치 : 디스크, SSD, CD-ROM
        
6. 반도체 기억장치

    1. RAM (Random Access Memory)
        
        작동 원리

            1. CS -> 0 : RD -> X, WR -> X : RAM 동작 = 선택 X
            2. CS -> 1 : RD -> 1, WR -> 0 : RAM 동작 = 읽기 동작
            3. CS -> 1 : RD -> 0, WR -> 1 : RAM 동작 = 쓰기 동작
    
        제조 기술에 따른 분류

            1. DRAM (Dynamic RAM)

            특징
            
                1. 집적 밀도가 높음

                2. 주기적인 재충전 필요 -> 데이터 저장 상태 유지

                3. 집적 밀도 높음 -> 같은 용량의 SRAM 보다 비트당 가격이 더 저렴

                4. 영량이 큰 주기억장치 사용
            
            2. SRAM (Static RAM)

                1. 집적 밀도가 낮음

                2. 전원 공급되는 동안 재충전 없이 데이터 계속 유지 가능

                3. DRAM보다 다소 더 빠름

                4. 높은 속도가 필요한 캐시 메모리 사용
        
        용량에 따른 주소 비트 수

            8 * 8 비트 조직 -> 주소 비트 수 : 3, 데이터 입출력 선 수 : 8

                1. 8Kbit RAM -> 1K * 8bit -> 주소 : 10비트 필요

                2. 1Mbit RAM -> 128k * 8bit -> 주소 : 17비트 필요

                3. 1Gbit RAM -> 128M * 8bit -> 주소 : 27비트 필요

            16 * 4 비트 조직 -> 주소 비트 수 : 4, 데이터 입출력 선 수 : 4

                1. 8Kbit RAM -> 2K * 4bit -> 주소 : 11비트 필요

                2. 1Mbit RAM -> 256k * 4bit -> 주소 : 18비트 필요

                3. 1Gbit RAM -> 256M * 4bit -> 주소 : 28비트 필요
            
            64 * 1 비트 조직 -> 6개의 주소 비트 필요 , 두 개의 3 * 8 해독기 필요, 입출력 수 = 1

                상위 3비트 -> 8개의 행 중에 한 개 선택
                하위 3비트 -> 8개의 열 중에 한 개 선택

                1. 8Kbit RAM -> 8K * 1bit -> 주소 : 13비트 필요

                2. 1Mbit RAM -> 1M * 1bit -> 주소 : 20비트 필요

                3. 1Gbit RAM -> 1G * 1bit -> 주소 : 30비트 필요성
    
    2. ROM (Read Only Memory)

        종류

            1. PROM (Programmable ROM) : 한 번 정도 쓰는 것이 가능한 ROM

            2. EPROM (Erasable Programmable ROM) : 자외선 이용 -> 내용을 지우는 것이 가능함, 여러번 쓰기 가능
            
            3. EEPROM (Electrically Erasable PROM) : 전기적으로 지울 수 있은 EPROM, 데이터 갱신 횟수 제한 (수 만번)

            4. 플래시 메모리

                1. NAND형 : 페이지 (2KB / 4KB) 단위 읽기, 쓰기 가능, 블록(64 / 128페이지) 단위 삭제

                2. NOR형 : 바이트 단위 읽기 / 쓰기 가능

                3. EEPROM에 비해 삭제 시간이 더 빠르며 집적 밀도도 더 높음

                4. 삭제 횟수 제한 (10만 ~ 100만)

7. 기억 장치 모듈의 설계

    1. 기억 장치 칩의 데이터 I/O 비트 수 < 단어 길이 : 여러 개의 칩들을 병렬로 접속 -> 구성

        단어 길이 : N 비트, 기억 장치 칩의 데이터 I/O 비트 수 = B -> N/B 개의 칩들을 병렬 접속

            1. N=8, 16 * 4비트 RAM 칩들을 이용한 기억장치 모듈 설계

                방법 : 2개의 RAM 칩들을 병렬 접속

                모듈 용량 : (16 * 4) * 2 = 16 * 8비트 = 16바이트

                주소 비트 (4개 :A_3 ~ A_0) : 두 칩들에 공통으로 접속

                칩 선택 선호도 : 두 칩들에게 공통으로 접속

                주소 영역 : 0000 ~ 1111
            
            2. 1K * 8비트 RAM 칩들을 이용한 1K * 32비트 기억장치 모듈 설계

                방법 : 4개의 RAM 칩들을 병렬 접속

                모듈 용량 : (1K * 8) * 4개 = 1K *32비트 = 1Kword

                주소 비트 ( 10개 : A9 ~ A0) : 모든 칩들에 공통으로 접속

                주소 영역 : 000H ~ 3FFH (단, H는 16진수 표시)

                데이터 저장 : 동일한 기억장치 주소에 대해 칩 당 (32 비트 중) 8비트씩 분산 저장

    2. 필요한 기억 장소 수 > 각 기억 장치 칩의 기억 장소 수 : 여러 개의 칩들을 직렬 접속 -> 기억 장치 모듈 구성

        두 개의 16 * 4비트 칩들을 이용한 32 * 4비트 기억 장치 모듈의 설계

            방법 : 2개의 RAM 칩들을 직렬 접속

            모듈 용량 : 2개 * (16 * 4) = 32 * 4비트

            주소 비트 수 : 5개 (A4 ~ A0)
                
                1. A4 : 칩 선택(CS) 신호로 사용

                2. A3~A0 : 두 칩들에 공통으로 접속
            
            주소 영역

                1. RAM1 : 00000 ~ 01111 (2)

                2. RAM2 : 10000 ~ 11111 (2)
        
        1K * 8 비트 RAM 칩들을 이용한 4K * 8비트 기억장치 모듈

            방법 : 4개의 RAM 칩 -> 직렬 접속

            모듈의 용량 : (1K * 8) * 4개 = 4K * 8 비트 = 4KByte

            주소 비트(12개 : A11 ~ A0) 접속 방법

                1. 상위 2 비트 (A11, A10) : 주소 해독기를 이용하여 내 개의 칩 선택(CS) 신호 발생

                2. 하위 10 비트 (A9 ~ A0) : 모든 칩들에 공통으로 접속
            
            전체 주소 영역 : 000H ~ FFFH

            데이터 버스 : 모든 기억 장치 칩에 공통 접속 -> 한 번에 8비트 씩 액세스

                RAM 1 : (0 0 0 0 / 0 0 1 1), (0 0 0 0 / 1 1 1 1), (0 0 0 0 / 1 1 1 1)
                    
                    16진수 표기 : 000H ~ 3FFH
                
                RAM 2 : (0 1 0 0 / 0 1 1 1), (0 0 0 0 / 1 1 1 1), (0 0 0 0 / 1 1 1 1)

                    16진수 표기 : 400H ~ 7FFH
                
                RAM 3 : (1 0 0 0 / 1 0 1 1), (0 0 0 0 / 1 1 1 1), (0 0 0 0 / 1 1 1 1)
                    16진수 표기 : 800H ~ BFFH
                
                RAM 4 : (1 1 0 0 / 1 1 1 1), (0 0 0 0 / 1 1 1 1), (0 0 0 0 / 1 1 1 1)
                    16진수 표기 : C00H ~ FFFH
    
    3. 기억 장치 모듈의 설계 순서

        ex : 8 - 비트 마이크로컴퓨터를 위한 기억 장치 설계

            필요 용량 : 1KByte ROM, 2KByte RAM

            주소 영역 : ROM = 0번지부터 RAM = 800H 번지부터

            사용 가능한 칩들 : 1K * 8bit ROM, 512 * 8bit RAMs

    4. 캐시 메모리

        사용 목적
        
            1. 주기억 장치 (DRAM)보다 액세스 속도가 더 높은 칩(SRAM) 사용

            2. 가격 및 제한된 공간 때문에 용량이 적음
    
    5. 캐시 기억장치

        1. 캐시 적중 : CPU -> 운하는 데이터가 캐시에 있는 상태

        2. 캐시 미스 : CPU -> 원하는 데이터가 캐시에 없는 상태

        2. 적중률 : 캐시에 적중되는 정도

            적중률 = (캐시에 적중되는 수) / (전체 기억장치 액세스 횟수)
        
        4. 캐시 미스율 : (1 - 적중률)

        5. 평균 기억장치 액세스 시간(Ta)

            Ta = H * Tc + (1-H) * Tm

            (단, H는 적중률, Tc는 캐시 액세스 시간, Tm은 주기억장치 액세스 시간)

        6. 캐시 설계에 있어서의 공통 목표

            1. 캐시 적중률의 극대화

            2. 캐시 액세스 시간의 최소화

            3. 캐시 미스에 따른 지연 시간의 최소화

            4. 주기억장치, 캐시 간 데이터 일관성 유지 및 그에 따른 오버헤드 최소화


        8. 사상 방식

            1. 직접 사상 : 각 주기억장치의 블록이 지정된 하나의 캐시 라인으로만 적재

                주소 형식

                    1. 태그 필드 (t bit) : 태그 번호 (라인에 적재되어 있는 블록의 번호)

                    2. 라인 번호 (L bit) : 캐시의 m = 2^t 개의 라인들 중의 하나를 지정

                    3. 단어 필드 (w bit) : 각 블록 내 2^w개 단어들 중의 하나를 구분함

                주기억장치의 블록 j가 적재될 수 있는 캐시 라인의 번호 i

                    i = j mod mod

                    (단, j : 주기억장치 블록 번호, m : 캐시 라인의 전체 수) 
                
                각 캐시 라인 : 2^n개의 블록들에 의해 공유됨

                같은 라인을 공유하는 블록들은 서로 다른 태그를 가짐

                동작 원리

                    1. 기억장치 주소 전송 -> l 비트의 라인 번호를 이용하여 캐시 라인 선택

                    2. 선택된 라인의 태그 비트 읽기 -> 주소의 태그 비트들과 비교

                        1. 캐시 적중 -> 주소의 w 비트들을 이용, 라인 내의 단어들 중 하나를 인출 -> CPU 전송

                        2. 캐시 미스

                            1. 주소 -> 주기억장치로 보내야 한 블록을 액세스

                            2. 인출된 블록 -> 지정된 캐시 라인 적재, 주소 태그 비트 -> 해당 라인의 태그 필드에 기록

                            3. if, 해당 라인에 다른 블록이 이미 적재 시 -> 해당 내용은 지워지고 새롭게 인출된 블록을 적재 및 태그 갱신

                    ex : 주기억장치 용량 = 128바이트, 주소 = 7비트, 블록 크기 = 4단어 -> (주기억 장치 : 128 / 4 =32개로 구성), 캐시 용량 32byte

                        1. 캐시 라인크기 : 4byte (블록 크기와 동일)

                        2. 전체 캐시 라인 수 : m = 32 / 4 = 8개

                        3. 주소 형식

                            tag = 2, line = 2, word = 2
                        
                        4. 각 기억장치 블록이 공유하게 될 캐시 라인 : i = j mod 8
                        
                        5. 직접 사상 캐시 적중 검사 예 ( 질문 : 캐시의 라인이 )

                            00 000 00 -> abcd
                            00 001 00 -> hand
                            00 010 00
                            00 011 00 -> univ
                            00 100 00
                            00 101 00 -> assm
                            00 110 00 -> para
                            00 111 00
                            01 000 00 -> drop
                            01 001 00
                            01 010 00 -> info
                            01 011 00
                            01 100 00
                            01 101 00
                            01 110 00
                            01 111 00 -> move
                            10 000 00 -> down
                            10 001 00
                            10 010 00
                            10 011 00
                            10 100 00
                            10 101 00
                            10 110 00 -> arch
                            10 111 00
                            11 001 00
                            11 010 00 -> comp
                            11 011 00 -> elec
                            11 100 00
                            11 101 00 -> tech
                            11 110 00
                            11 111 10

                            00 'abcd' 000
                            11 'comp' 010
                            00 'univ' 011
                            10 'arch' 110
                            01 'move' 111

                            1. 0101000 -> 01 010 00 -> 캐시 미스

                                1. 2번 (010) 라인의 데이터 필드 : info (i)

                                2. 태그 : 01

                            2. 0001101 -> 00 011 01 -> 캐시 적중

                            3. 1110111 -> 11 101 11 -> 캐시 미스

                                1. 5번 (101) 라인의 데이터 필드 : tech (h)

                                2. 태그 : 11
                            
                            4. 1011010 -> 10 110 10 -> 캐시 적중
                
                장단점

                    장점

                        하드웨어가 간단하고, 구현 비용이 적게 든다

                    단점

                        각 주기억장치 블록이 적재될 수 있는 캐시 라인이 한개 뿐임

                        해당라인이 공유하는 다른 블록이 적재된 경우 Overwrite 되거나 Swap-Out 됨
            
            2. 완전 - 연관 사상

                1. 기억장치 주소 형식 : 태그 필드 (t) , 단어 필드 (w)

                2. 직접 사상 캐시의 예에 완전 - 연관 사상 방식 적용

                    NULL | 태그 (5비트) | 단어 (2비트)
                
                장단점

                    장점

                        1. 새로운 블록이캐시로 적재될 때 라인의 선택이 매우 자유로움

                        2. 지역성이 높으면 적중률이 매우 높아짐

                    단점

                        1. 캐시 라인들의 태그들을 병렬로 검사하기 위해 가격이 높은 연관 기억장치 및 복잡한 주변 회로 필요
                
                        예시
                            00 000 00 -> abcd
                            00 001 00 -> hand
                            00 010 00
                            00 011 00 -> univ
                            00 100 00
                            00 101 00 -> assm
                            00 110 00 -> para
                            00 111 00
                            01 000 00 -> drop
                            01 001 00
                            01 010 00 -> info
                            01 011 00
                            01 100 00
                            01 101 00
                            01 110 00
                            01 111 00 -> move
                            10 000 00 -> down
                            10 001 00
                            10 010 00
                            10 011 00
                            10 100 00
                            10 101 00
                            10 110 00 -> arch
                            10 111 00
                            11 001 00
                            11 010 00 -> comp
                            11 011 00 -> elec
                            11 100 00
                            11 101 00 -> tech
                            11 110 00
                            11 111 10

                            00001 'hand' 000
                            01111 'move' 001
                            11010 'comp' 010
                            10110 'arch' 011
                            01010 'info' 100

                            1011000 -> 10110 00 -> 캐시 적중
                            0010110 -> 00101 10 -> 캐시 미스
                            0000001 -> 00000 01 -> 캐시 미스
                            0111111 -> 01111 11 -> 캐시 적중
            
            3. 세트 - 연관 사상

                1. 직접 사상과 완전 - 연관 사상의 조합

                2. 주기억장치 블록 그룹이 하나의 캐시 세트 공유 -> 해당 세트에 두 개 이상의 라인들이 적재될 수 있음

                3. 캐시 : v 개의 세트들로 나눔 -> 각 세트들 : k개의 라인들로 구성 ( = k-way 세트 - 연관 사상)

                4. 주기억장치 블록이 적재될 수 있는 캐시 세트 번호 i : i=j mov v

                    (단, i : 캐시 세트 번호, j : 주기억장치 블록 번호, v : 캐시 세트들의 수)

                6. 기억장치 주소 형식

                    1. 태그 필드와 세트 필드를 합한 비트 (t+s)가 주기억장치의 2^(t+s) 블록들 중 하나를 지정

                    2. 해당 블록이 적재될 수 있는 세트 번호 : 세트 필드에 의해 지정

                        t = 태그 필드 -> s = 세트 필드 -> w = 단어 필드

                    3. 2-way 세트 - 연관 사상 방식을 직접 사상 방식으로 적용할 때 다음과 같음

                        태그 = 3 line -> 세트 = 2 line -> 단어 = 2 line
                
                7. 동작 원리

                    1. 기억 장치 주소의 세트 필드 s를 이용 -> 캐시 세트들 중 하나 서낵

                    2. 주소의 태그 필드 내용과 해당 세트 내의 태그들을 비교함

                        1. 일치 -> 캐시 적중 -> 해당 라인 내 한 단어를 w 비트에 의해 선택하여 인출

                        2. 일치 X -> 캐시 미스에

                            1. 주기억장치 액세스
                            
                            2. 세트 내 라인들중 한 라인에 새로운 블록 적재 -> 교체 알고리즘 필요

                    3. 예시

                        1. 주기억장치 용량 = 128 바이트, 블록 크기 = 4단어 -> 주기억장치 블록 수 : 128 / 4 = 32개

                        2. 캐시 용량 = 32바이트, 라인 크기 = 4바이트 -> 라인 수 : 32 / 4 = 8개

                        3. 세트당 라인 수 = 2 -> 캐시 내 세트 수 v = 8 / 2 = 4개

                            000 00 00 -> abcd
                            000 01 00 -> hand
                            000 10 00
                            000 11 00 -> univ
                            001 00 00
                            001 01 00 -> assm
                            001 10 00 -> para
                            001 11 00
                            010 00 00 -> drop
                            010 01 00
                            010 10 00 -> info
                            010 11 00
                            011 00 00
                            011 01 00
                            011 10 00
                            011 11 00 -> move
                            100 00 00 -> down
                            100 01 00
                            100 10 00
                            100 11 00
                            101 00 00
                            101 01 00
                            101 10 00 -> arch
                            101 11 00
                            110 00 00
                            110 01 00
                            110 10 00 -> comp
                            110 11 00 -> elec
                            111 00 00
                            111 01 00 -> tech
                            111 10 00
                            111 11 10

                            000 'abcd'  010 'drop'  00
                            001 'assm'              01
                            010 'info'  101 'arch'  10
                            000 'univ'              11

                            1. 1011010 -> 101 10 10 -> 캐시 적중
                            2. 1110101 -> 111 01 01 -> 캐시 미스 : 1번 세트의 두 번쨰 라인에 tech 적재
                            3. 1000000 -> 100 00 00 -> 캐시 미스 : 0번 세트의 첫 번째 라인에 down 적재
                            4. 0001111 -> 000 11 11 -> 캐시 적중
                        
                        4. 큰 용량의 세트 - 연관 사상 캐시 조직 예

                            1. 주기억장치 용량 16M -> 주기억장치 주소 : 24비트, 바이트 단위로 주소 저장
                                
                                이유 : 16M -> k^2 * 2^4 = (2^10)^2 * 2^4 = 2^24
                            
                            2. 주기억장치는 4-단어 크기의 블록들 4M (2^24 / 2^2 = 2^22)개로 구성

                            3. 캐시의 용량은 64k (2^16)바이트 이다. -> 이유를 모르겠음

                            4. 주기억장치의 블록 크기가 4바이트 -> 캐시 라인의 크기도 4바이트가 됨

                            5. 결과 : 라인 수 m = 16k (2^16 / 2^2 = 2^4 * 2^10 = 16 * K)

                            6. 2-way 세트 -연관 사상 조직으로 가정한다면 세트의 수는 (2^4 * 2^10 / 2way = 8K)

                    4. 쉽게 구별하는 사상

                        1. 세트 수 = 캐시 라인수이며 (v = k )세트 내 라인 수 k =1 -> 직접 사상
                        2. 세트 수 = 1, 세트 내 라인 수 = 캐시 전체라인 수 (k = m) -> 완전 - 연관 사상과
        
        9. 교체 알고리즘

            1. 캐시 적중률을 극대화할 수 있도록 교체할 블록을 선택하기 위한 알고리즘

                1. FIFO -> 캐시에 적재된 지 가장 오래된 블록 교체할

                2. LRU -> 사용되지 않은 채로 가장 오래 있었던 블록을 교체하는 방식

                3. LFU -> 참조된 횟수가 가장 적은 블록을 교체하는 방식
        
        10 쓰기 정책

            종류

                1. Write -through : 모든 쓰기 동작들이 캐시와 주기억 장치로도 동시에 수행함

                    장점 : 캐시에 적재된 블록의 내용과 주기억장치에 있는 그 블록의 내용이 항상 같음

                    단점 : 모든 쓰기 동작이 주기억장치 쓰기를 포함함 -> 쓰기 시간이 길어짐

                2. Write-back : 캐시에서 데이터가 변경되어소 주기억장치에는 갱신되지 않는 방식

                    장점 : 기억장치에 대한 쓰기 동작의 횟수 최소화, 쓰기 시간 단축

                    단점 : 캐시 내용과 주기억 장치의 해당 내용이 서로 다름 (데이터 불일치 현상)

                        케시의 데이터가 수정된 적이 있는 경우

                            1. 블록을 교체할 때 주기억장치에 갱신하는 동작 선행

                            2. 그를 위한 각 캐시 라인이 상태 비트를 가지고 있어야 함

                                상대 비트 = 0 : 유효
                                
                                상대 비트 = 1 : 수정
        
        11. 다중 캐시

            1. 계층적 캐시 
                
                1. 온-칩 캐시를 1차 (L1) 캐시로 사용

                2. 칩 외부 or 칩 내부에 더 큰 용량의 2차 (L2) 캐시를 추가 설치

            2. 2-단계 케시 시스템의 평균 기억장치 액세스 시간:

                Ta = H1 * T_L1 + (H2 - H1) * T_L2 + (1- H2) * Tm
                
                만약 H2가 L1에서 미스 된 액세스들에 대한 L2의 적중률일 떄 다음과 같음

                    Ta = H1 * T_L1 + (1-H1) * H2 * T_L2 + {(1-H1) - (1-H1) * H2} * Tm

8. DDR SDRAM

    1. 기억 장치의 액세스 속도 -> CPU에 비해 현저히 낮음

    2. 주기억장치 병목 현상 심화 -> 대규모 데이터 처리 응용이 증가하는 추세

    종류

        1. SDRAM : 동기식 DRAM

            원리

                1. CPU 1 클럭 : 주소 읽기 신호 -> 시스템 버스 -> 기억장치 -> 내부에서 다른 연산 수행

                2. SDRAM : 주소 읽기 신호 -> 받자마자 동작 시작 -> 완료 -> 시스템 버스 사용권 획득 -> 버스 -> 다음 클록 주기 -> CPU 데이터 전송

                3. CPU : 데이터를 받아 다음 연산을 수행함

        2. DDR SDRAM

            1. SDRAM 기억 장치 모듈의 대역폭 향상시키기 위한기술

            2. DDR SDRAM : 버스 클록 당 두 번의 데이터 전송

                1. 클록 펄스의 상승-예지

                2. 클록 펄스의 하강-예지
            
            3. DDR2 SDRAM : DDR SDRAM과 같으며 버스 클록 수파수를 두 배로 높여 대역폭 향상

                읽기 시간 비교 (ex : 버스트 길이 = 8)

                1. SDR @ 133MHz [PC133]

                    1. 버스 클록 = 133MHz

                    2. 매 클록 주기 (7.5ns)마다 64비트씩 전송

                    3. 8번의 데이터 전송에 걸리는 시간

                        -> CAS 지연 (15ns) + {7.5ns * 8} = 75ns

                2. DDR @ 133MHz [DDR-266]

                    1. 상승 및 하강 에지에서 64비트씩 전송

                    2. 8번의 데이터 전송에 걸리는 시간

                        -> CAS 지연(15ns) + {(7.5ns / 2) * 8} = 45ns
                
                3. DDR-2 @ 266MHz [DDR-533]

                    1. 버스 클록 = 266MHz (주기 = 3.75ns)

                    2. 상승 및 하강 에지마다 64비트씩 전송

                    3. 8번의 데이터 전송에 걸리는 시간

                        -> CAS 지연(15ns) + {(3.75ns / 2) * 8} = 30ns
                    
                데이터 전송 시간 (CAS 지연 제외) 비교 :

                    60ns (SDR) -> 30ns (DDR) -> 15ns (DDR-2)
        
        3. DDR 기술의 기본 원리

            1. 버스 클록의 상승 에지와 하강 에지에서 각각 데이터 전송

            2. 기억장치 제어기 및 버스 인터페이스 회로의 개선을 통해 버스 클록 주파수 향상

            3. DDR3 및 DDR4도 같은 원리를 적용하여 설계

        4. 기억장치 대역폭

            1. 단위 시간 당 데이터 전송량

            2. 버스 폭 * 클록 주파수

            ex : 데이터 버스 = 64비트, 버스 클록 주파수 = 100MHz

                대역폭 : (100MHz * 64) / 8 비트 = 800 [Mbytes / sec]

                SDR @133MHz : (133MHz x 64) / 8 = 1064[Mbytes/sec]

                DDR @133MHz : (133MHz x 2 x 64) / 8 = 2128[Mbytes/sec]

                DDR2 @266MHz : (266MHz x 2 x 64) / 8 = 4256[Mbytes/sec]
        
        5. CAS 지연

            DDR : SDRAM 칩의 CAS 지연 = 15ns, 클록 주기 = 7.5ns, 따라서 CAS 지연 = 2주기

            DDR2 : f=266MHz (클록 주기 = 3.75ns) -> CAS 지연 = 4주기 (15ns / 3.75ㅜㄴ = 4주기)

            DDR3, DDR4에 사용되는 SDRAM 칩들의 CAS 지연 = 10ns

            DDR3-1600 @ 800MHz : CAS 지연 = 8주기

            DDR4-3200 @ 1600MHz : CAS 지연 = 16주기

        6. 기억장치 랭크

            1. 데이터 입출력 폭이 64비트가 되도록 구성한 기억장치 모듈

                예시

                    1. * 4 조직의 SDRAM 사용 -> 16개를 병렬 접속

                    2. * 8 조직의 SDRAM 사용 -> 8개를 병렬 접속
            
            2. 주 기판의 기억장치 슬롯에 정착

                1. 단면모둘

                    1. 기판의 한 면에만 칩들을 장착함

                    2. 접속 핀들은한 면에만 설치하거나 양면에 중복적으로 설치

                    3. SIMM이라고 부름

                2. 양면모듈

                    1. 기판의 양 면에 칩들을 장착함

                    2. 접속 핀들도 양면에 설치하여 많은 신호 입출력 가능

                    3. DIMM이라고 부름
            
            3. 단일 - 랭크 모듈

                1. 단면 모듈 상에 * 8 조직의 SDRAM 8개를 병렬 접속 함

                2. 하나의 랭크를 구성함

                3. 64비트 데이터가 한 번에 버스를 통하여 전송되도록 구성한 기억장치 모듈

                    1. 각 SDRAM 칩의 용량이 2Gbit (256 M * 8 bit)일 때 가정

                    2. SIMM 전체 용량 = 256Mbyte * 8개 = 2Gbit
            
            4. 2중 - 랭크 모듈

                1. 양면 모듈 (DIMM)에서 * 8 조직의 SDRAM들을 각 면에 8개씩 병렬 접속함

                2. 두 개의 랭크를 구성한 기억장치 모듈

                    1. 각 SDRAM 칩의 용량이 2Gbit일 떄 가정

                    2. DIMM의 전체 용량 = 256Mbyte * 8 * 2면 = 4Gbyte
            
            5. * 4 조직의 SDRAM 칩들을 사용하는 경우

                1. 16개를 병렬접속하여 양면모듈 (DIMM)에 하나의 랭크를 구성함

                2. 읽기 동작 -> 주소가 인가되면 각 칩에서 4비트씩 인출되어 전체적으로 64비트가 데이터 버스로 전송함

                    1. 각 SDRAM 칩의 용량이 2Gbit일 때 가정

                    2. DIMM의 전체 용량 = (512 M * 4) * 16개 = 4Gbyte
            
            6. 4중 - 랭크 모듈

                1. * 16 조직의 SDRAM 칩 사용

                2. 면당 두 랭크씩 구성

                3. 용량은 앞의 조직들과 동일

                    높은 신뢰도가 요구되는 경우

                        1. 데이터 8비트 당 한 비트씩 오류 검출코드 (ECC) 추가







                    




