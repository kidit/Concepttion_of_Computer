1. Protection

    1. 프로세스가 해당 주소 공간에 있는 주소에만 접근하도록 지원 - Legal address

    2. Provide -> a pair of base & limit register -> define the logical address space

        1. Base : the smallest legal physical memory address

        2. Limit : the size of the range
    
2. Hardware Address Protection

    1. CPU는 다음과 같이 확인

        1. Base <= CPU && Base + limit > CPU

    2. The instructions to loading the base and limit registers are privileged

        1. Kernel mode, OS only -> 사용자 프로그램은 변경 못함

3. Logical Vs Physical Address space

    1. Physical address space -> binding logical address space = 메모리 관리 핵심

        1. Logical address -> generated by the CPU : also referred to as virtual address

        2. Physical address -> address seen by the memory unit

    2. Logical and physical addresses are the same
    
        1. compile - time
        2. load - time address - binding schemes

    3. Logical (virtual) and physical addresses differ

        1. execution - time address - binding schemes

    4. Logica address space : 프로그램에 의해 생성된 모든 논리 주소의 집합

    5. Physical address space : 프로그램에 의해 생성된 모든 물리적 주소 집합

4. binding of instructions and Data to memory

    1. Three different stages

        1. Compile time

        2. Load time

        3. Execution time

5. memory - Management unit (MMU)

    1. Hardware device that at run time maps virtual to physical address

        CPU -> (logical address) -> MMU -> (physical address) -> physical memory

6. Variable Partition (가변 파티션)

    1. Multiple - partition allocation

        1. Degree of multiprogramming limited by number of partitions

        2. Variable - partition size for effeciency

            1. Sized to a given process needs
        
        3. Hole - block of available memory

            1. holes of various size are scattered throughout memory
        
        4. When a process arrives -> allocated memory from a hole large enough to accommodate instructions

        5. Process exiting frees its partition, adjacent free partitions combined
    
    2. Operating System maintains information about

        1. allocated partitions

        2. free partitions (hole)

7. Dynamic Storage - Allocation Problem

    1.  How to satisfy a request of size n from a list of free holes?
    
        1. First -fit : first hole that is big enough

        2. Best - fit : smallest hole that is big enough

            1. must search entire list

            2. unless ordered by size

                1. Produces the smallest leftover hole
            
        3. Worst - fit : Allocate the largest hole

            1. must also search entire list

                1. Produces the largest leftover holes

8. Fragmentation

    1. External Fragmentation (외부 단편화) - 총 메모리 공간이 요청을 충족시키기 위해 존재

        1. 불연속적임
    
    2. Internal Fragmentation (내부 단편화) - 할당된 메모리는 요청된 메모리보다 약간 클 수 있음

        1. 크기 차이는 파티션 내부에 메모리지만 사용 안 됨

    3. First fit analysis reveals that given N block allocated

        1. another o.5 N blocks lost to Fragmentation

        2. 1/3 may be unusable -> 50 - percent rule

9. Paging

    1. Physical address space of a process can be noncontiguous

        1. process is allocated physical memory whenever the latter is available

            1. Avoids external Fragmentation and compaction
        
        2. Divide physical memory into fixed - size blocks called frames

            1. Size is power of 2

            2. between 512 bytes and 16M bytes

        3. Divide logical memory into blocks of same size called pages

        4. Keep track of all free frames

        5. To run a program of size N pages

            1. need to find N free frames and load program
        
        6. Set up a page table to translate logical to physical addresses

        7. Backing store likewise split into pages

        8. Still have Internal Fragmentation

10. memory Protection

    1. Memory protection 구현

        1. 읽기 전용 또는 읽기 / 쓰기 액세스가 허용되는지 여부를 나타내기 위해 보호 비트를 각 ㅍ프레임과 연결

        2. Can also add more bits to indicate page execute - only , and so on

    2. Valid - invalid bit attached to each entry in the page table

        1. "valid" 연결된 페이지 -> 프로세스의 논리적 주소 공간에 있음 = 합법적인 페이지임을 나타냄

        2. "Invalid" 페이지 -> 프로세스의 논리적 주소 공간에 없음을 나타냄

        3. Or use page - table length register (PTLR)

    3. Any violations result in a trap to the Kernel

11. Inverted Page table

    1. Decreases memory needed to store each page table

    2. But increases time needed to search the table

        1. when a page reference occurs
    
    3. Use hash table to limit the search to one - or at most a frw -page - table

        1. TLB can accelerate access

    4. But how to implement shared memory?

        1. Cannot be used with inverted page table

        2. One mapping of a virtual address to the shared physical address
        